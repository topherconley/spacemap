% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crossValidation.R
\name{cvVote}
\alias{cvVote}
\title{Cross validation (CV.Vote) for spacemap and space models.}
\usage{
cvVote(Y, X = NULL, trainIds, testIds, method = c("spacemap", "space"),
  tuneGrid, resPath = tempdir(), refit = TRUE, thresh = 0.5,
  iscale = TRUE, aszero = 1e-06, ...)
}
\arguments{
\item{Y}{Numeric matrix \eqn{(N \times Q)} containing N iid samples of the response vector \eqn{\textbf{y}}.}

\item{X}{Numeric matrix \eqn{(N \times P)} containing N iid samples of the predictor vector \eqn{\textbf{x}}.}

\item{trainIds}{List of integer vectors, where each integer vector contains 
a split of training sample indices pertaining to \code{Y, X}.}

\item{testIds}{List of integer vectors, where each integer vector contains 
a split of  test sample indices pertaining to \code{Y, X}. Required to 
be of the same length as \code{trainIds}.}

\item{method}{Character vector indicates network inference with function 
\code{\link{spacemap}} when \code{method = "spacemap"} or function 
\code{\link{space.joint}} when \code{method = "space"}. If \code{X} is 
non-null and \code{method = "space"}, then \code{space.joint} will 
infer (x--x, x--y, y--y) edges but only report (x--y, y--y) edges.}

\item{tuneGrid}{Named with columns \code{lam1, lam2, lam3} 
when \code{method = "spacemap"}. Each row in the data.frame corresponds to a
 tuning parameter set that is input into \code{\link{spacemap}}. 
When \code{method = "space"}, supply a data.frame with only one column 
being \code{lam1}.}

\item{resPath}{Character vector specifying the directory where each 
model fit is written to file through serialization by \code{saveRDS}. 
Defaults to temporary directory that will be deleted at end of the R session. 
It is recommended to specify a directory where results can be stored permanently.}

\item{refit}{Logical indicates to refit the model after convergence to
reduce bias induced by penalty terms. Default to TRUE. The refit step
defaults to a  ridge regression with small penalty of 0.01 to 
encourage numerical stability. The user can change the ridge
penalty by adding an additional parameter \code{refitRidge}.}

\item{thresh}{}

\item{iscale}{Logical indicating to standardize the whole input data. Defaults to TRUE. 
See \code{\link{base::scale(x, center = TRUE, scale = TRUE)}} for details of standardization.}

\item{aszero}{Positive numeric value (defaults to 1e-6) indicating at what point to consider extremely 
small parameter estimates of \eqn{\Gamma} and \eqn{\rho} as zero.}

\item{...}{Additional arguments for \code{\link{spacemap}} or \code{\link{space.joint}}
to change their default settings (e.g. setting \code{tol = 1e-4}).}
}
\value{
A list containing  
\itemize {  
 \item \code{cvVote} A list containing
 \enumerate{
 \item \code{xy} Adjacency matrix where \eqn{xy(p,q)} element
  is 1 for an edge between \eqn{x_p} and \eqn{y_q} and 0 otherwise. 
  \item \code{yy} Adjacency matrix where \eqn{yy(q,l)} element
  is 1 for an edge between \eqn{y_q} and \eqn{y_l} and 0 otherwise. 
 }
 \item \code{minTune} List containing the optimal tuning penalty set. 
 \item \code{minIndex} Integer specifying the index of \code{minTune} in \code{tuneGrid}. 
 \item \code{metricScores} Data.frame for input to \code{\link{tuneVis}} for
 inspecting the CV score curve and model size as a function of the tuning penalties.
}
}
\description{
Selects and returns best-tuned model under CV.Vote.
}
\examples{
data(sim1)
##########################
#DEFINE TRAINING/TEST SETS
library(caret)
#sample size
N <- nrow(sim1$X)
#number of folds
K <- 5L
set.seed(265616L)
#no special population structure, but create randomized dummy structure of A and B
testSets <- createFolds(y = sample(x = c("A", "B"), size = N, replace = TRUE), k = K)
trainSets <- lapply(testSets, function(s) setdiff(seq_len(N), s))
nsplits <- sapply(testSets, length)
##########################
#SPACE (Y input)
tsp <- expand.grid(lam1 = seq(65, 75, length = 3))
cvspace <- cvVote(Y = sim1$Y, 
                 trainIds = trainSets, testIds = testSets, 
                 method = "space", tuneGrid = tsp) 
##########################
# SPACEMAP (Y and X input)
tmap <- expand.grid(lam1 = seq(65, 75, length = 2), 
                   lam2 = seq(21, 35, length = 2), 
                   lam3 = seq(10, 40, length = 2))
cvsmap <- cvVote(Y = sim1$Y, X = sim1$X, 
                trainIds = trainSets, testIds = testSets, 
                method = "spacemap", tuneGrid = tmap)
                
}
